// @generated by protoc-gen-es v1.3.3 with parameter "target=ts"
// @generated from file engine_service.proto (package engine_api, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum engine_api.EnclaveMode
 */
export enum EnclaveMode {
  /**
   * @generated from enum value: TEST = 0;
   */
  TEST = 0,

  /**
   * @generated from enum value: PRODUCTION = 1;
   */
  PRODUCTION = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(EnclaveMode)
proto3.util.setEnumType(EnclaveMode, "engine_api.EnclaveMode", [
  { no: 0, name: "TEST" },
  { no: 1, name: "PRODUCTION" },
]);

/**
 * ==============================================================================================
 *                                            Get Enclaves
 * ==============================================================================================
 * Status of the containers in the enclave
 * NOTE: We have to prefix the enum values with the enum name due to the way Protobuf enum valuee uniqueness works
 *
 * @generated from enum engine_api.EnclaveContainersStatus
 */
export enum EnclaveContainersStatus {
  /**
   * The enclave has been created, but there are no containers inside it
   *
   * @generated from enum value: EnclaveContainersStatus_EMPTY = 0;
   */
  EnclaveContainersStatus_EMPTY = 0,

  /**
   * One or more containers are running in the enclave (which may or may not include the API container, depending on if the user was manually stopping/removing containers)
   *
   * @generated from enum value: EnclaveContainersStatus_RUNNING = 1;
   */
  EnclaveContainersStatus_RUNNING = 1,

  /**
   * There are >= 1 container in the enclave, but they're all stopped
   *
   * @generated from enum value: EnclaveContainersStatus_STOPPED = 2;
   */
  EnclaveContainersStatus_STOPPED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EnclaveContainersStatus)
proto3.util.setEnumType(EnclaveContainersStatus, "engine_api.EnclaveContainersStatus", [
  { no: 0, name: "EnclaveContainersStatus_EMPTY" },
  { no: 1, name: "EnclaveContainersStatus_RUNNING" },
  { no: 2, name: "EnclaveContainersStatus_STOPPED" },
]);

/**
 * NOTE: We have to prefix the enum values with the enum name due to the way Protobuf enum value uniqueness works
 *
 * @generated from enum engine_api.EnclaveAPIContainerStatus
 */
export enum EnclaveAPIContainerStatus {
  /**
   * No API container exists in the enclave
   * This is the only valid value when the enclave containers status is "EMPTY"
   *
   * @generated from enum value: EnclaveAPIContainerStatus_NONEXISTENT = 0;
   */
  EnclaveAPIContainerStatus_NONEXISTENT = 0,

  /**
   * An API container exists and is running
   * NOTE: this does NOT say that the server inside the API container is available, because checking if it's available requires making a call to the API container
   *  If we have a lot of API containers, we'd be making tons of calls
   *
   * @generated from enum value: EnclaveAPIContainerStatus_RUNNING = 1;
   */
  EnclaveAPIContainerStatus_RUNNING = 1,

  /**
   * An API container exists, but isn't running
   *
   * @generated from enum value: EnclaveAPIContainerStatus_STOPPED = 2;
   */
  EnclaveAPIContainerStatus_STOPPED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EnclaveAPIContainerStatus)
proto3.util.setEnumType(EnclaveAPIContainerStatus, "engine_api.EnclaveAPIContainerStatus", [
  { no: 0, name: "EnclaveAPIContainerStatus_NONEXISTENT" },
  { no: 1, name: "EnclaveAPIContainerStatus_RUNNING" },
  { no: 2, name: "EnclaveAPIContainerStatus_STOPPED" },
]);

/**
 * The filter operator which can be text or regex type
 * NOTE: We have to prefix the enum values with the enum name due to the way Protobuf enum value uniqueness works
 *
 * @generated from enum engine_api.LogLineOperator
 */
export enum LogLineOperator {
  /**
   * @generated from enum value: LogLineOperator_DOES_CONTAIN_TEXT = 0;
   */
  LogLineOperator_DOES_CONTAIN_TEXT = 0,

  /**
   * @generated from enum value: LogLineOperator_DOES_NOT_CONTAIN_TEXT = 1;
   */
  LogLineOperator_DOES_NOT_CONTAIN_TEXT = 1,

  /**
   * @generated from enum value: LogLineOperator_DOES_CONTAIN_MATCH_REGEX = 2;
   */
  LogLineOperator_DOES_CONTAIN_MATCH_REGEX = 2,

  /**
   * @generated from enum value: LogLineOperator_DOES_NOT_CONTAIN_MATCH_REGEX = 3;
   */
  LogLineOperator_DOES_NOT_CONTAIN_MATCH_REGEX = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LogLineOperator)
proto3.util.setEnumType(LogLineOperator, "engine_api.LogLineOperator", [
  { no: 0, name: "LogLineOperator_DOES_CONTAIN_TEXT" },
  { no: 1, name: "LogLineOperator_DOES_NOT_CONTAIN_TEXT" },
  { no: 2, name: "LogLineOperator_DOES_CONTAIN_MATCH_REGEX" },
  { no: 3, name: "LogLineOperator_DOES_NOT_CONTAIN_MATCH_REGEX" },
]);

/**
 * ==============================================================================================
 *                                        Get Engine Info
 * ==============================================================================================
 *
 * @generated from message engine_api.GetEngineInfoResponse
 */
export class GetEngineInfoResponse extends Message<GetEngineInfoResponse> {
  /**
   * Version of the engine server
   *
   * @generated from field: string engine_version = 1;
   */
  engineVersion = "";

  constructor(data?: PartialMessage<GetEngineInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.GetEngineInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEngineInfoResponse {
    return new GetEngineInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEngineInfoResponse {
    return new GetEngineInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEngineInfoResponse {
    return new GetEngineInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetEngineInfoResponse | PlainMessage<GetEngineInfoResponse> | undefined, b: GetEngineInfoResponse | PlainMessage<GetEngineInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetEngineInfoResponse, a, b);
  }
}

/**
 * ==============================================================================================
 *                                        Create Enclave
 * ==============================================================================================
 *
 * @generated from message engine_api.CreateEnclaveArgs
 */
export class CreateEnclaveArgs extends Message<CreateEnclaveArgs> {
  /**
   * The name of the new Kurtosis Enclave
   *
   * @generated from field: string enclave_name = 1;
   */
  enclaveName = "";

  /**
   * The image tag of the API container that should be used inside the enclave
   * If blank, will use the default version that the engine server uses
   *
   * @generated from field: string api_container_version_tag = 2;
   */
  apiContainerVersionTag = "";

  /**
   * The API container log level
   *
   * @generated from field: string api_container_log_level = 3;
   */
  apiContainerLogLevel = "";

  /**
   * @generated from field: engine_api.EnclaveMode mode = 4;
   */
  mode = EnclaveMode.TEST;

  constructor(data?: PartialMessage<CreateEnclaveArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.CreateEnclaveArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "api_container_version_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "api_container_log_level", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "mode", kind: "enum", T: proto3.getEnumType(EnclaveMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateEnclaveArgs {
    return new CreateEnclaveArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateEnclaveArgs {
    return new CreateEnclaveArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateEnclaveArgs {
    return new CreateEnclaveArgs().fromJsonString(jsonString, options);
  }

  static equals(a: CreateEnclaveArgs | PlainMessage<CreateEnclaveArgs> | undefined, b: CreateEnclaveArgs | PlainMessage<CreateEnclaveArgs> | undefined): boolean {
    return proto3.util.equals(CreateEnclaveArgs, a, b);
  }
}

/**
 * @generated from message engine_api.CreateEnclaveResponse
 */
export class CreateEnclaveResponse extends Message<CreateEnclaveResponse> {
  /**
   * All the enclave information inside this object
   *
   * @generated from field: engine_api.EnclaveInfo enclave_info = 1;
   */
  enclaveInfo?: EnclaveInfo;

  constructor(data?: PartialMessage<CreateEnclaveResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.CreateEnclaveResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_info", kind: "message", T: EnclaveInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateEnclaveResponse {
    return new CreateEnclaveResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateEnclaveResponse {
    return new CreateEnclaveResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateEnclaveResponse {
    return new CreateEnclaveResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateEnclaveResponse | PlainMessage<CreateEnclaveResponse> | undefined, b: CreateEnclaveResponse | PlainMessage<CreateEnclaveResponse> | undefined): boolean {
    return proto3.util.equals(CreateEnclaveResponse, a, b);
  }
}

/**
 * @generated from message engine_api.EnclaveAPIContainerInfo
 */
export class EnclaveAPIContainerInfo extends Message<EnclaveAPIContainerInfo> {
  /**
   * The container engine ID of the API container
   *
   * @generated from field: string container_id = 1;
   */
  containerId = "";

  /**
   * The IP inside the enclave network of the API container (i.e. how services inside the network can reach the API container)
   *
   * @generated from field: string ip_inside_enclave = 2;
   */
  ipInsideEnclave = "";

  /**
   * The grpc port inside the enclave network that the API container is listening on
   *
   * @generated from field: uint32 grpc_port_inside_enclave = 3;
   */
  grpcPortInsideEnclave = 0;

  /**
   * this is the bridge ip address that gets assigned to api container
   *
   * @generated from field: string bridge_ip_address = 6;
   */
  bridgeIpAddress = "";

  constructor(data?: PartialMessage<EnclaveAPIContainerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.EnclaveAPIContainerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "container_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ip_inside_enclave", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "grpc_port_inside_enclave", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "bridge_ip_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnclaveAPIContainerInfo {
    return new EnclaveAPIContainerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnclaveAPIContainerInfo {
    return new EnclaveAPIContainerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnclaveAPIContainerInfo {
    return new EnclaveAPIContainerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: EnclaveAPIContainerInfo | PlainMessage<EnclaveAPIContainerInfo> | undefined, b: EnclaveAPIContainerInfo | PlainMessage<EnclaveAPIContainerInfo> | undefined): boolean {
    return proto3.util.equals(EnclaveAPIContainerInfo, a, b);
  }
}

/**
 * Will only be present if the API container is running
 *
 * @generated from message engine_api.EnclaveAPIContainerHostMachineInfo
 */
export class EnclaveAPIContainerHostMachineInfo extends Message<EnclaveAPIContainerHostMachineInfo> {
  /**
   * The interface IP on the container engine host machine where the API container can be reached
   *
   * @generated from field: string ip_on_host_machine = 4;
   */
  ipOnHostMachine = "";

  /**
   * The grpc port on the container engine host machine where the API container can be reached
   *
   * @generated from field: uint32 grpc_port_on_host_machine = 5;
   */
  grpcPortOnHostMachine = 0;

  constructor(data?: PartialMessage<EnclaveAPIContainerHostMachineInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.EnclaveAPIContainerHostMachineInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "ip_on_host_machine", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "grpc_port_on_host_machine", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnclaveAPIContainerHostMachineInfo {
    return new EnclaveAPIContainerHostMachineInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnclaveAPIContainerHostMachineInfo {
    return new EnclaveAPIContainerHostMachineInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnclaveAPIContainerHostMachineInfo {
    return new EnclaveAPIContainerHostMachineInfo().fromJsonString(jsonString, options);
  }

  static equals(a: EnclaveAPIContainerHostMachineInfo | PlainMessage<EnclaveAPIContainerHostMachineInfo> | undefined, b: EnclaveAPIContainerHostMachineInfo | PlainMessage<EnclaveAPIContainerHostMachineInfo> | undefined): boolean {
    return proto3.util.equals(EnclaveAPIContainerHostMachineInfo, a, b);
  }
}

/**
 * Enclaves are defined by a network in the container system, which is why there's a bunch of network information here
 *
 * @generated from message engine_api.EnclaveInfo
 */
export class EnclaveInfo extends Message<EnclaveInfo> {
  /**
   * UUID of the enclave
   *
   * @generated from field: string enclave_uuid = 1;
   */
  enclaveUuid = "";

  /**
   * Name of the enclave
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The shortened uuid of the enclave
   *
   * @generated from field: string shortened_uuid = 3;
   */
  shortenedUuid = "";

  /**
   * State of all containers in the enclave
   *
   * @generated from field: engine_api.EnclaveContainersStatus containers_status = 4;
   */
  containersStatus = EnclaveContainersStatus.EnclaveContainersStatus_EMPTY;

  /**
   * State specifically of the API container
   *
   * @generated from field: engine_api.EnclaveAPIContainerStatus api_container_status = 5;
   */
  apiContainerStatus = EnclaveAPIContainerStatus.EnclaveAPIContainerStatus_NONEXISTENT;

  /**
   * NOTE: Will not be present if the API container status is "NONEXISTENT"!!
   *
   * @generated from field: engine_api.EnclaveAPIContainerInfo api_container_info = 6;
   */
  apiContainerInfo?: EnclaveAPIContainerInfo;

  /**
   * NOTE: Will not be present if the API container status is not "RUNNING"!!
   *
   * @generated from field: engine_api.EnclaveAPIContainerHostMachineInfo api_container_host_machine_info = 7;
   */
  apiContainerHostMachineInfo?: EnclaveAPIContainerHostMachineInfo;

  /**
   * The enclave's creation time
   *
   * @generated from field: google.protobuf.Timestamp creation_time = 8;
   */
  creationTime?: Timestamp;

  /**
   * @generated from field: engine_api.EnclaveMode mode = 9;
   */
  mode = EnclaveMode.TEST;

  constructor(data?: PartialMessage<EnclaveInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.EnclaveInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "shortened_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "containers_status", kind: "enum", T: proto3.getEnumType(EnclaveContainersStatus) },
    { no: 5, name: "api_container_status", kind: "enum", T: proto3.getEnumType(EnclaveAPIContainerStatus) },
    { no: 6, name: "api_container_info", kind: "message", T: EnclaveAPIContainerInfo },
    { no: 7, name: "api_container_host_machine_info", kind: "message", T: EnclaveAPIContainerHostMachineInfo },
    { no: 8, name: "creation_time", kind: "message", T: Timestamp },
    { no: 9, name: "mode", kind: "enum", T: proto3.getEnumType(EnclaveMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnclaveInfo {
    return new EnclaveInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnclaveInfo {
    return new EnclaveInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnclaveInfo {
    return new EnclaveInfo().fromJsonString(jsonString, options);
  }

  static equals(a: EnclaveInfo | PlainMessage<EnclaveInfo> | undefined, b: EnclaveInfo | PlainMessage<EnclaveInfo> | undefined): boolean {
    return proto3.util.equals(EnclaveInfo, a, b);
  }
}

/**
 * @generated from message engine_api.GetEnclavesResponse
 */
export class GetEnclavesResponse extends Message<GetEnclavesResponse> {
  /**
   * Mapping of enclave_uuid -> info_about_enclave
   *
   * @generated from field: map<string, engine_api.EnclaveInfo> enclave_info = 1;
   */
  enclaveInfo: { [key: string]: EnclaveInfo } = {};

  constructor(data?: PartialMessage<GetEnclavesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.GetEnclavesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: EnclaveInfo} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEnclavesResponse {
    return new GetEnclavesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEnclavesResponse {
    return new GetEnclavesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEnclavesResponse {
    return new GetEnclavesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetEnclavesResponse | PlainMessage<GetEnclavesResponse> | undefined, b: GetEnclavesResponse | PlainMessage<GetEnclavesResponse> | undefined): boolean {
    return proto3.util.equals(GetEnclavesResponse, a, b);
  }
}

/**
 * An enclave identifier is a collection of uuid, name and shortened uuid
 *
 * @generated from message engine_api.EnclaveIdentifiers
 */
export class EnclaveIdentifiers extends Message<EnclaveIdentifiers> {
  /**
   * UUID of the enclave
   *
   * @generated from field: string enclave_uuid = 1;
   */
  enclaveUuid = "";

  /**
   * Name of the enclave
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The shortened uuid of the enclave
   *
   * @generated from field: string shortened_uuid = 3;
   */
  shortenedUuid = "";

  constructor(data?: PartialMessage<EnclaveIdentifiers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.EnclaveIdentifiers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "shortened_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnclaveIdentifiers {
    return new EnclaveIdentifiers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnclaveIdentifiers {
    return new EnclaveIdentifiers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnclaveIdentifiers {
    return new EnclaveIdentifiers().fromJsonString(jsonString, options);
  }

  static equals(a: EnclaveIdentifiers | PlainMessage<EnclaveIdentifiers> | undefined, b: EnclaveIdentifiers | PlainMessage<EnclaveIdentifiers> | undefined): boolean {
    return proto3.util.equals(EnclaveIdentifiers, a, b);
  }
}

/**
 * @generated from message engine_api.GetExistingAndHistoricalEnclaveIdentifiersResponse
 */
export class GetExistingAndHistoricalEnclaveIdentifiersResponse extends Message<GetExistingAndHistoricalEnclaveIdentifiersResponse> {
  /**
   * @generated from field: repeated engine_api.EnclaveIdentifiers allIdentifiers = 1;
   */
  allIdentifiers: EnclaveIdentifiers[] = [];

  constructor(data?: PartialMessage<GetExistingAndHistoricalEnclaveIdentifiersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.GetExistingAndHistoricalEnclaveIdentifiersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allIdentifiers", kind: "message", T: EnclaveIdentifiers, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExistingAndHistoricalEnclaveIdentifiersResponse {
    return new GetExistingAndHistoricalEnclaveIdentifiersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExistingAndHistoricalEnclaveIdentifiersResponse {
    return new GetExistingAndHistoricalEnclaveIdentifiersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExistingAndHistoricalEnclaveIdentifiersResponse {
    return new GetExistingAndHistoricalEnclaveIdentifiersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetExistingAndHistoricalEnclaveIdentifiersResponse | PlainMessage<GetExistingAndHistoricalEnclaveIdentifiersResponse> | undefined, b: GetExistingAndHistoricalEnclaveIdentifiersResponse | PlainMessage<GetExistingAndHistoricalEnclaveIdentifiersResponse> | undefined): boolean {
    return proto3.util.equals(GetExistingAndHistoricalEnclaveIdentifiersResponse, a, b);
  }
}

/**
 * ==============================================================================================
 *                                       Stop Enclave
 * ==============================================================================================
 *
 * @generated from message engine_api.StopEnclaveArgs
 */
export class StopEnclaveArgs extends Message<StopEnclaveArgs> {
  /**
   * The identifier(uuid, shortened uuid, name) of the Kurtosis enclave to stop
   *
   * @generated from field: string enclave_identifier = 1;
   */
  enclaveIdentifier = "";

  constructor(data?: PartialMessage<StopEnclaveArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.StopEnclaveArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopEnclaveArgs {
    return new StopEnclaveArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopEnclaveArgs {
    return new StopEnclaveArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopEnclaveArgs {
    return new StopEnclaveArgs().fromJsonString(jsonString, options);
  }

  static equals(a: StopEnclaveArgs | PlainMessage<StopEnclaveArgs> | undefined, b: StopEnclaveArgs | PlainMessage<StopEnclaveArgs> | undefined): boolean {
    return proto3.util.equals(StopEnclaveArgs, a, b);
  }
}

/**
 * ==============================================================================================
 *                                       Destroy Enclave
 * ==============================================================================================
 *
 * @generated from message engine_api.DestroyEnclaveArgs
 */
export class DestroyEnclaveArgs extends Message<DestroyEnclaveArgs> {
  /**
   * The identifier(uuid, shortened uuid, name) of the Kurtosis enclave to destroy
   *
   * @generated from field: string enclave_identifier = 1;
   */
  enclaveIdentifier = "";

  constructor(data?: PartialMessage<DestroyEnclaveArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.DestroyEnclaveArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestroyEnclaveArgs {
    return new DestroyEnclaveArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestroyEnclaveArgs {
    return new DestroyEnclaveArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestroyEnclaveArgs {
    return new DestroyEnclaveArgs().fromJsonString(jsonString, options);
  }

  static equals(a: DestroyEnclaveArgs | PlainMessage<DestroyEnclaveArgs> | undefined, b: DestroyEnclaveArgs | PlainMessage<DestroyEnclaveArgs> | undefined): boolean {
    return proto3.util.equals(DestroyEnclaveArgs, a, b);
  }
}

/**
 * ==============================================================================================
 *                                       Create Enclave
 * ==============================================================================================
 *
 * @generated from message engine_api.CleanArgs
 */
export class CleanArgs extends Message<CleanArgs> {
  /**
   * If true, It will clean even the running enclaves
   *
   * @generated from field: bool should_clean_all = 1;
   */
  shouldCleanAll = false;

  constructor(data?: PartialMessage<CleanArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.CleanArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "should_clean_all", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CleanArgs {
    return new CleanArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CleanArgs {
    return new CleanArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CleanArgs {
    return new CleanArgs().fromJsonString(jsonString, options);
  }

  static equals(a: CleanArgs | PlainMessage<CleanArgs> | undefined, b: CleanArgs | PlainMessage<CleanArgs> | undefined): boolean {
    return proto3.util.equals(CleanArgs, a, b);
  }
}

/**
 * @generated from message engine_api.EnclaveNameAndUuid
 */
export class EnclaveNameAndUuid extends Message<EnclaveNameAndUuid> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string uuid = 2;
   */
  uuid = "";

  constructor(data?: PartialMessage<EnclaveNameAndUuid>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.EnclaveNameAndUuid";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnclaveNameAndUuid {
    return new EnclaveNameAndUuid().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnclaveNameAndUuid {
    return new EnclaveNameAndUuid().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnclaveNameAndUuid {
    return new EnclaveNameAndUuid().fromJsonString(jsonString, options);
  }

  static equals(a: EnclaveNameAndUuid | PlainMessage<EnclaveNameAndUuid> | undefined, b: EnclaveNameAndUuid | PlainMessage<EnclaveNameAndUuid> | undefined): boolean {
    return proto3.util.equals(EnclaveNameAndUuid, a, b);
  }
}

/**
 * @generated from message engine_api.CleanResponse
 */
export class CleanResponse extends Message<CleanResponse> {
  /**
   * removed enclave name and uuids
   *
   * @generated from field: repeated engine_api.EnclaveNameAndUuid removed_enclave_name_and_uuids = 1;
   */
  removedEnclaveNameAndUuids: EnclaveNameAndUuid[] = [];

  constructor(data?: PartialMessage<CleanResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.CleanResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "removed_enclave_name_and_uuids", kind: "message", T: EnclaveNameAndUuid, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CleanResponse {
    return new CleanResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CleanResponse {
    return new CleanResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CleanResponse {
    return new CleanResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CleanResponse | PlainMessage<CleanResponse> | undefined, b: CleanResponse | PlainMessage<CleanResponse> | undefined): boolean {
    return proto3.util.equals(CleanResponse, a, b);
  }
}

/**
 * ==============================================================================================
 *                                   Get User Service Logs
 * ==============================================================================================
 *
 * @generated from message engine_api.GetServiceLogsArgs
 */
export class GetServiceLogsArgs extends Message<GetServiceLogsArgs> {
  /**
   * The identifier of the user service's Kurtosis Enclave
   *
   * @generated from field: string enclave_identifier = 1;
   */
  enclaveIdentifier = "";

  /**
   * "Set" of service UUIDs in the enclave
   *
   * @generated from field: map<string, bool> service_uuid_set = 2;
   */
  serviceUuidSet: { [key: string]: boolean } = {};

  /**
   * If true, It will follow the container logs
   *
   * @generated from field: bool follow_logs = 3;
   */
  followLogs = false;

  /**
   * The conjunctive log lines filters, the first filter is applied over the found log lines, the second filter is applied over the filter one result and so on (like grep)
   *
   * @generated from field: repeated engine_api.LogLineFilter conjunctive_filters = 4;
   */
  conjunctiveFilters: LogLineFilter[] = [];

  /**
   * If true, return all log lines
   *
   * @generated from field: bool return_all_logs = 5;
   */
  returnAllLogs = false;

  /**
   * If [return_all_logs] is false, return [num_log_lines]
   *
   * @generated from field: uint32 num_log_lines = 6;
   */
  numLogLines = 0;

  constructor(data?: PartialMessage<GetServiceLogsArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.GetServiceLogsArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enclave_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "service_uuid_set", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
    { no: 3, name: "follow_logs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "conjunctive_filters", kind: "message", T: LogLineFilter, repeated: true },
    { no: 5, name: "return_all_logs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "num_log_lines", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServiceLogsArgs {
    return new GetServiceLogsArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServiceLogsArgs {
    return new GetServiceLogsArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServiceLogsArgs {
    return new GetServiceLogsArgs().fromJsonString(jsonString, options);
  }

  static equals(a: GetServiceLogsArgs | PlainMessage<GetServiceLogsArgs> | undefined, b: GetServiceLogsArgs | PlainMessage<GetServiceLogsArgs> | undefined): boolean {
    return proto3.util.equals(GetServiceLogsArgs, a, b);
  }
}

/**
 * @generated from message engine_api.GetServiceLogsResponse
 */
export class GetServiceLogsResponse extends Message<GetServiceLogsResponse> {
  /**
   * The service log lines grouped by service UUIDs and ordered in forward direction (oldest log line is the first element)
   *
   * @generated from field: map<string, engine_api.LogLine> service_logs_by_service_uuid = 1;
   */
  serviceLogsByServiceUuid: { [key: string]: LogLine } = {};

  /**
   * A set of service GUIDs requested by the user that were not found in the logs database, could be related that users send
   * a wrong GUID or a right GUID for a service that has not sent any logs so far
   *
   * @generated from field: map<string, bool> not_found_service_uuid_set = 2;
   */
  notFoundServiceUuidSet: { [key: string]: boolean } = {};

  constructor(data?: PartialMessage<GetServiceLogsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.GetServiceLogsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_logs_by_service_uuid", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LogLine} },
    { no: 2, name: "not_found_service_uuid_set", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServiceLogsResponse {
    return new GetServiceLogsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServiceLogsResponse {
    return new GetServiceLogsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServiceLogsResponse {
    return new GetServiceLogsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetServiceLogsResponse | PlainMessage<GetServiceLogsResponse> | undefined, b: GetServiceLogsResponse | PlainMessage<GetServiceLogsResponse> | undefined): boolean {
    return proto3.util.equals(GetServiceLogsResponse, a, b);
  }
}

/**
 * TODO add timestamp as well, for when we do timestamp-handling on the client side
 *
 * @generated from message engine_api.LogLine
 */
export class LogLine extends Message<LogLine> {
  /**
   * @generated from field: repeated string line = 1;
   */
  line: string[] = [];

  constructor(data?: PartialMessage<LogLine>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.LogLine";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogLine {
    return new LogLine().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogLine {
    return new LogLine().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogLine {
    return new LogLine().fromJsonString(jsonString, options);
  }

  static equals(a: LogLine | PlainMessage<LogLine> | undefined, b: LogLine | PlainMessage<LogLine> | undefined): boolean {
    return proto3.util.equals(LogLine, a, b);
  }
}

/**
 * @generated from message engine_api.LogLineFilter
 */
export class LogLineFilter extends Message<LogLineFilter> {
  /**
   * @generated from field: engine_api.LogLineOperator operator = 1;
   */
  operator = LogLineOperator.LogLineOperator_DOES_CONTAIN_TEXT;

  /**
   * @generated from field: string text_pattern = 2;
   */
  textPattern = "";

  constructor(data?: PartialMessage<LogLineFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "engine_api.LogLineFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator", kind: "enum", T: proto3.getEnumType(LogLineOperator) },
    { no: 2, name: "text_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogLineFilter {
    return new LogLineFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogLineFilter {
    return new LogLineFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogLineFilter {
    return new LogLineFilter().fromJsonString(jsonString, options);
  }

  static equals(a: LogLineFilter | PlainMessage<LogLineFilter> | undefined, b: LogLineFilter | PlainMessage<LogLineFilter> | undefined): boolean {
    return proto3.util.equals(LogLineFilter, a, b);
  }
}

