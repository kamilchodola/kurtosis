// @generated by protoc-gen-es v1.3.3 with parameter "target=ts"
// @generated from file api_container_service.proto (package api_container_api, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum api_container_api.ServiceStatus
 */
export enum ServiceStatus {
  /**
   * @generated from enum value: STOPPED = 0;
   */
  STOPPED = 0,

  /**
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: UNKNOWN = 2;
   */
  UNKNOWN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ServiceStatus)
proto3.util.setEnumType(ServiceStatus, "api_container_api.ServiceStatus", [
  { no: 0, name: "STOPPED" },
  { no: 1, name: "RUNNING" },
  { no: 2, name: "UNKNOWN" },
]);

/**
 * User services port forwarding
 *
 * @generated from enum api_container_api.Connect
 */
export enum Connect {
  /**
   * Best effort port forwarding
   *
   * @generated from enum value: CONNECT = 0;
   */
  CONNECT = 0,

  /**
   * Port forwarding disabled
   *
   * Starlark run fails if the ports cannot be forwarded.
   * MUST_CONNECT = 2;
   *
   * @generated from enum value: NO_CONNECT = 1;
   */
  NO_CONNECT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Connect)
proto3.util.setEnumType(Connect, "api_container_api.Connect", [
  { no: 0, name: "CONNECT" },
  { no: 1, name: "NO_CONNECT" },
]);

/**
 * @generated from enum api_container_api.KurtosisFeatureFlag
 */
export enum KurtosisFeatureFlag {
  /**
   * @generated from enum value: NO_INSTRUCTIONS_CACHING = 0;
   */
  NO_INSTRUCTIONS_CACHING = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(KurtosisFeatureFlag)
proto3.util.setEnumType(KurtosisFeatureFlag, "api_container_api.KurtosisFeatureFlag", [
  { no: 0, name: "NO_INSTRUCTIONS_CACHING" },
]);

/**
 * @generated from enum api_container_api.RestartPolicy
 */
export enum RestartPolicy {
  /**
   * @generated from enum value: NEVER = 0;
   */
  NEVER = 0,

  /**
   * @generated from enum value: ALWAYS = 1;
   */
  ALWAYS = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RestartPolicy)
proto3.util.setEnumType(RestartPolicy, "api_container_api.RestartPolicy", [
  { no: 0, name: "NEVER" },
  { no: 1, name: "ALWAYS" },
]);

/**
 * ==============================================================================================
 *                           Shared Objects (Used By Multiple Endpoints)
 * ==============================================================================================
 *
 * @generated from message api_container_api.Port
 */
export class Port extends Message<Port> {
  /**
   * @generated from field: uint32 number = 1;
   */
  number = 0;

  /**
   * The protocol that the port is listening on
   *
   * @generated from field: api_container_api.Port.TransportProtocol transport_protocol = 2;
   */
  transportProtocol = Port_TransportProtocol.TCP;

  /**
   * @generated from field: string maybe_application_protocol = 3;
   */
  maybeApplicationProtocol = "";

  /**
   * The wait timeout duration in string
   *
   * @generated from field: string maybe_wait_timeout = 4;
   */
  maybeWaitTimeout = "";

  constructor(data?: PartialMessage<Port>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.Port";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "number", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "transport_protocol", kind: "enum", T: proto3.getEnumType(Port_TransportProtocol) },
    { no: 3, name: "maybe_application_protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maybe_wait_timeout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Port {
    return new Port().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Port {
    return new Port().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Port {
    return new Port().fromJsonString(jsonString, options);
  }

  static equals(a: Port | PlainMessage<Port> | undefined, b: Port | PlainMessage<Port> | undefined): boolean {
    return proto3.util.equals(Port, a, b);
  }
}

/**
 * @generated from enum api_container_api.Port.TransportProtocol
 */
export enum Port_TransportProtocol {
  /**
   * @generated from enum value: TCP = 0;
   */
  TCP = 0,

  /**
   * @generated from enum value: SCTP = 1;
   */
  SCTP = 1,

  /**
   * @generated from enum value: UDP = 2;
   */
  UDP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Port_TransportProtocol)
proto3.util.setEnumType(Port_TransportProtocol, "api_container_api.Port.TransportProtocol", [
  { no: 0, name: "TCP" },
  { no: 1, name: "SCTP" },
  { no: 2, name: "UDP" },
]);

/**
 * @generated from message api_container_api.Container
 */
export class Container extends Message<Container> {
  /**
   * @generated from field: api_container_api.Container.Status status = 1;
   */
  status = Container_Status.STOPPED;

  /**
   * @generated from field: string image_name = 2;
   */
  imageName = "";

  /**
   * @generated from field: repeated string entrypoint_args = 3;
   */
  entrypointArgs: string[] = [];

  /**
   * @generated from field: repeated string cmd_args = 4;
   */
  cmdArgs: string[] = [];

  /**
   * @generated from field: map<string, string> env_vars = 5;
   */
  envVars: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Container>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.Container";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(Container_Status) },
    { no: 2, name: "image_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entrypoint_args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "cmd_args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "env_vars", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Container {
    return new Container().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Container {
    return new Container().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Container {
    return new Container().fromJsonString(jsonString, options);
  }

  static equals(a: Container | PlainMessage<Container> | undefined, b: Container | PlainMessage<Container> | undefined): boolean {
    return proto3.util.equals(Container, a, b);
  }
}

/**
 * @generated from enum api_container_api.Container.Status
 */
export enum Container_Status {
  /**
   * @generated from enum value: STOPPED = 0;
   */
  STOPPED = 0,

  /**
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: UNKNOWN = 2;
   */
  UNKNOWN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Container_Status)
proto3.util.setEnumType(Container_Status, "api_container_api.Container.Status", [
  { no: 0, name: "STOPPED" },
  { no: 1, name: "RUNNING" },
  { no: 2, name: "UNKNOWN" },
]);

/**
 * @generated from message api_container_api.ServiceInfo
 */
export class ServiceInfo extends Message<ServiceInfo> {
  /**
   * UUID of the service
   *
   * @generated from field: string service_uuid = 1;
   */
  serviceUuid = "";

  /**
   * The IP address of the service inside the enclave
   *
   * @generated from field: string private_ip_addr = 2;
   */
  privateIpAddr = "";

  /**
   * The ports on which the service is reachable inside the enclave, specified in user_specified_port_id -> port_info
   * Will be exactly what was passed in at the time of starting the service
   *
   * @generated from field: map<string, api_container_api.Port> private_ports = 3;
   */
  privatePorts: { [key: string]: Port } = {};

  /**
   * Public IP address *outside* the enclave where the service is reachable
   * NOTE: Will be empty if the service isn't running, the service didn't define any ports, or the backend doesn't support reporting public service info
   *
   * @generated from field: string maybe_public_ip_addr = 4;
   */
  maybePublicIpAddr = "";

  /**
   * Mapping defining the ports that the service can be reached at *outside* the enclave, in the user_defined_port_id -> port_info where user_defined_port_id
   *  corresponds to the ID that was passed in in AddServiceArgs
   * NOTE: Will be empty if the service isn't running, the service didn't define any ports, or the backend doesn't support reporting public service info
   *
   * @generated from field: map<string, api_container_api.Port> maybe_public_ports = 5;
   */
  maybePublicPorts: { [key: string]: Port } = {};

  /**
   * Name of the service
   *
   * @generated from field: string name = 6;
   */
  name = "";

  /**
   * Shortened uuid of the service
   *
   * @generated from field: string shortened_uuid = 7;
   */
  shortenedUuid = "";

  /**
   * Service status: stopped, running.
   *
   * @generated from field: api_container_api.ServiceStatus service_status = 8;
   */
  serviceStatus = ServiceStatus.STOPPED;

  /**
   * Docker container or Kubernetes pod container
   *
   * @generated from field: api_container_api.Container container = 9;
   */
  container?: Container;

  constructor(data?: PartialMessage<ServiceInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ServiceInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "private_ip_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "private_ports", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Port} },
    { no: 4, name: "maybe_public_ip_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "maybe_public_ports", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Port} },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "shortened_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "service_status", kind: "enum", T: proto3.getEnumType(ServiceStatus) },
    { no: 9, name: "container", kind: "message", T: Container },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceInfo {
    return new ServiceInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceInfo {
    return new ServiceInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceInfo {
    return new ServiceInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceInfo | PlainMessage<ServiceInfo> | undefined, b: ServiceInfo | PlainMessage<ServiceInfo> | undefined): boolean {
    return proto3.util.equals(ServiceInfo, a, b);
  }
}

/**
 * @generated from message api_container_api.RunStarlarkScriptArgs
 */
export class RunStarlarkScriptArgs extends Message<RunStarlarkScriptArgs> {
  /**
   * @generated from field: string serialized_script = 1;
   */
  serializedScript = "";

  /**
   * @generated from field: string serialized_params = 2;
   */
  serializedParams = "";

  /**
   * Defaults to false
   *
   * @generated from field: optional bool dry_run = 3;
   */
  dryRun?: boolean;

  /**
   * Defaults to 4
   *
   * @generated from field: optional int32 parallelism = 4;
   */
  parallelism?: number;

  /**
   * The name of the main function, the default value is "run"
   *
   * @generated from field: string main_function_name = 5;
   */
  mainFunctionName = "";

  /**
   * @generated from field: repeated api_container_api.KurtosisFeatureFlag experimental_features = 6;
   */
  experimentalFeatures: KurtosisFeatureFlag[] = [];

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_instance_id = 7;
   */
  cloudInstanceId?: string;

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_user_id = 8;
   */
  cloudUserId?: string;

  constructor(data?: PartialMessage<RunStarlarkScriptArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.RunStarlarkScriptArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "serialized_script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "serialized_params", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "parallelism", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "main_function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "experimental_features", kind: "enum", T: proto3.getEnumType(KurtosisFeatureFlag), repeated: true },
    { no: 7, name: "cloud_instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "cloud_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunStarlarkScriptArgs {
    return new RunStarlarkScriptArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunStarlarkScriptArgs {
    return new RunStarlarkScriptArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunStarlarkScriptArgs {
    return new RunStarlarkScriptArgs().fromJsonString(jsonString, options);
  }

  static equals(a: RunStarlarkScriptArgs | PlainMessage<RunStarlarkScriptArgs> | undefined, b: RunStarlarkScriptArgs | PlainMessage<RunStarlarkScriptArgs> | undefined): boolean {
    return proto3.util.equals(RunStarlarkScriptArgs, a, b);
  }
}

/**
 * @generated from message api_container_api.RunStarlarkPackageArgs
 */
export class RunStarlarkPackageArgs extends Message<RunStarlarkPackageArgs> {
  /**
   * @generated from field: string package_id = 1;
   */
  packageId = "";

  /**
   * Deprecated: If the package is local, it should have been uploaded with UploadStarlarkPackage prior to calling
   * RunStarlarkPackage. If the package is remote and must be cloned within the APIC, use the standalone boolean flag
   * clone_package below
   *
   * @generated from oneof api_container_api.RunStarlarkPackageArgs.starlark_package_content
   */
  starlarkPackageContent: {
    /**
     * the payload of the local module
     *
     * @generated from field: bytes local = 3;
     */
    value: Uint8Array;
    case: "local";
  } | {
    /**
     * just a flag to indicate the module must be cloned inside the API
     *
     * @generated from field: bool remote = 4;
     */
    value: boolean;
    case: "remote";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Serialized parameters data for the Starlark package main function
   * This should be a valid JSON string
   *
   * @generated from field: string serialized_params = 5;
   */
  serializedParams = "";

  /**
   * Defaults to false
   *
   * @generated from field: optional bool dry_run = 6;
   */
  dryRun?: boolean;

  /**
   * Defaults to 4
   *
   * @generated from field: optional int32 parallelism = 7;
   */
  parallelism?: number;

  /**
   * Whether the package should be cloned or not.
   * If false, then the package will be pulled from the APIC local package store. If it's a local package then is must
   * have been uploaded using UploadStarlarkPackage prior to calling RunStarlarkPackage.
   * If true, then the package will be cloned from GitHub before execution starts
   *
   * @generated from field: optional bool clone_package = 8;
   */
  clonePackage?: boolean;

  /**
   * The relative main file filepath, the default value is the "main.star" file in the root of a package
   *
   * @generated from field: string relative_path_to_main_file = 9;
   */
  relativePathToMainFile = "";

  /**
   * The name of the main function, the default value is "run"
   *
   * @generated from field: string main_function_name = 10;
   */
  mainFunctionName = "";

  /**
   * @generated from field: repeated api_container_api.KurtosisFeatureFlag experimental_features = 11;
   */
  experimentalFeatures: KurtosisFeatureFlag[] = [];

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_instance_id = 12;
   */
  cloudInstanceId?: string;

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_user_id = 13;
   */
  cloudUserId?: string;

  constructor(data?: PartialMessage<RunStarlarkPackageArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.RunStarlarkPackageArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "package_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "local", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "starlark_package_content" },
    { no: 4, name: "remote", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "starlark_package_content" },
    { no: 5, name: "serialized_params", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "parallelism", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "clone_package", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 9, name: "relative_path_to_main_file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "main_function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "experimental_features", kind: "enum", T: proto3.getEnumType(KurtosisFeatureFlag), repeated: true },
    { no: 12, name: "cloud_instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 13, name: "cloud_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunStarlarkPackageArgs {
    return new RunStarlarkPackageArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunStarlarkPackageArgs {
    return new RunStarlarkPackageArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunStarlarkPackageArgs {
    return new RunStarlarkPackageArgs().fromJsonString(jsonString, options);
  }

  static equals(a: RunStarlarkPackageArgs | PlainMessage<RunStarlarkPackageArgs> | undefined, b: RunStarlarkPackageArgs | PlainMessage<RunStarlarkPackageArgs> | undefined): boolean {
    return proto3.util.equals(RunStarlarkPackageArgs, a, b);
  }
}

/**
 * ==============================================================================================
 *                               Starlark Execution Response
 * ==============================================================================================
 *
 * @generated from message api_container_api.StarlarkRunResponseLine
 */
export class StarlarkRunResponseLine extends Message<StarlarkRunResponseLine> {
  /**
   * @generated from oneof api_container_api.StarlarkRunResponseLine.run_response_line
   */
  runResponseLine: {
    /**
     * @generated from field: api_container_api.StarlarkInstruction instruction = 1;
     */
    value: StarlarkInstruction;
    case: "instruction";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkError error = 2;
     */
    value: StarlarkError;
    case: "error";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkRunProgress progress_info = 3;
     */
    value: StarlarkRunProgress;
    case: "progressInfo";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkInstructionResult instruction_result = 4;
     */
    value: StarlarkInstructionResult;
    case: "instructionResult";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkRunFinishedEvent run_finished_event = 5;
     */
    value: StarlarkRunFinishedEvent;
    case: "runFinishedEvent";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkWarning warning = 6;
     */
    value: StarlarkWarning;
    case: "warning";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkInfo info = 7;
     */
    value: StarlarkInfo;
    case: "info";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StarlarkRunResponseLine>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkRunResponseLine";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instruction", kind: "message", T: StarlarkInstruction, oneof: "run_response_line" },
    { no: 2, name: "error", kind: "message", T: StarlarkError, oneof: "run_response_line" },
    { no: 3, name: "progress_info", kind: "message", T: StarlarkRunProgress, oneof: "run_response_line" },
    { no: 4, name: "instruction_result", kind: "message", T: StarlarkInstructionResult, oneof: "run_response_line" },
    { no: 5, name: "run_finished_event", kind: "message", T: StarlarkRunFinishedEvent, oneof: "run_response_line" },
    { no: 6, name: "warning", kind: "message", T: StarlarkWarning, oneof: "run_response_line" },
    { no: 7, name: "info", kind: "message", T: StarlarkInfo, oneof: "run_response_line" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkRunResponseLine {
    return new StarlarkRunResponseLine().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkRunResponseLine {
    return new StarlarkRunResponseLine().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkRunResponseLine {
    return new StarlarkRunResponseLine().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkRunResponseLine | PlainMessage<StarlarkRunResponseLine> | undefined, b: StarlarkRunResponseLine | PlainMessage<StarlarkRunResponseLine> | undefined): boolean {
    return proto3.util.equals(StarlarkRunResponseLine, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkInfo
 */
export class StarlarkInfo extends Message<StarlarkInfo> {
  /**
   * @generated from field: string info_message = 1;
   */
  infoMessage = "";

  constructor(data?: PartialMessage<StarlarkInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInfo {
    return new StarlarkInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInfo {
    return new StarlarkInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInfo {
    return new StarlarkInfo().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkInfo | PlainMessage<StarlarkInfo> | undefined, b: StarlarkInfo | PlainMessage<StarlarkInfo> | undefined): boolean {
    return proto3.util.equals(StarlarkInfo, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkWarning
 */
export class StarlarkWarning extends Message<StarlarkWarning> {
  /**
   * @generated from field: string warning_message = 1;
   */
  warningMessage = "";

  constructor(data?: PartialMessage<StarlarkWarning>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkWarning";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "warning_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkWarning {
    return new StarlarkWarning().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkWarning {
    return new StarlarkWarning().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkWarning {
    return new StarlarkWarning().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkWarning | PlainMessage<StarlarkWarning> | undefined, b: StarlarkWarning | PlainMessage<StarlarkWarning> | undefined): boolean {
    return proto3.util.equals(StarlarkWarning, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkInstruction
 */
export class StarlarkInstruction extends Message<StarlarkInstruction> {
  /**
   * @generated from field: api_container_api.StarlarkInstructionPosition position = 1;
   */
  position?: StarlarkInstructionPosition;

  /**
   * @generated from field: string instruction_name = 2;
   */
  instructionName = "";

  /**
   * @generated from field: repeated api_container_api.StarlarkInstructionArg arguments = 3;
   */
  arguments: StarlarkInstructionArg[] = [];

  /**
   * @generated from field: string executable_instruction = 4;
   */
  executableInstruction = "";

  /**
   * @generated from field: bool is_skipped = 5;
   */
  isSkipped = false;

  constructor(data?: PartialMessage<StarlarkInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkInstruction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: StarlarkInstructionPosition },
    { no: 2, name: "instruction_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arguments", kind: "message", T: StarlarkInstructionArg, repeated: true },
    { no: 4, name: "executable_instruction", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "is_skipped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstruction {
    return new StarlarkInstruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstruction {
    return new StarlarkInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstruction {
    return new StarlarkInstruction().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkInstruction | PlainMessage<StarlarkInstruction> | undefined, b: StarlarkInstruction | PlainMessage<StarlarkInstruction> | undefined): boolean {
    return proto3.util.equals(StarlarkInstruction, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkInstructionResult
 */
export class StarlarkInstructionResult extends Message<StarlarkInstructionResult> {
  /**
   * @generated from field: string serialized_instruction_result = 1;
   */
  serializedInstructionResult = "";

  constructor(data?: PartialMessage<StarlarkInstructionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkInstructionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "serialized_instruction_result", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstructionResult {
    return new StarlarkInstructionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstructionResult {
    return new StarlarkInstructionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstructionResult {
    return new StarlarkInstructionResult().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkInstructionResult | PlainMessage<StarlarkInstructionResult> | undefined, b: StarlarkInstructionResult | PlainMessage<StarlarkInstructionResult> | undefined): boolean {
    return proto3.util.equals(StarlarkInstructionResult, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkInstructionArg
 */
export class StarlarkInstructionArg extends Message<StarlarkInstructionArg> {
  /**
   * @generated from field: string serialized_arg_value = 1;
   */
  serializedArgValue = "";

  /**
   * @generated from field: optional string arg_name = 2;
   */
  argName?: string;

  /**
   * @generated from field: bool is_representative = 3;
   */
  isRepresentative = false;

  constructor(data?: PartialMessage<StarlarkInstructionArg>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkInstructionArg";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "serialized_arg_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "arg_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "is_representative", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstructionArg {
    return new StarlarkInstructionArg().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstructionArg {
    return new StarlarkInstructionArg().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstructionArg {
    return new StarlarkInstructionArg().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkInstructionArg | PlainMessage<StarlarkInstructionArg> | undefined, b: StarlarkInstructionArg | PlainMessage<StarlarkInstructionArg> | undefined): boolean {
    return proto3.util.equals(StarlarkInstructionArg, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkInstructionPosition
 */
export class StarlarkInstructionPosition extends Message<StarlarkInstructionPosition> {
  /**
   * @generated from field: string filename = 1;
   */
  filename = "";

  /**
   * @generated from field: int32 line = 2;
   */
  line = 0;

  /**
   * @generated from field: int32 column = 3;
   */
  column = 0;

  constructor(data?: PartialMessage<StarlarkInstructionPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkInstructionPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstructionPosition {
    return new StarlarkInstructionPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstructionPosition {
    return new StarlarkInstructionPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstructionPosition {
    return new StarlarkInstructionPosition().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkInstructionPosition | PlainMessage<StarlarkInstructionPosition> | undefined, b: StarlarkInstructionPosition | PlainMessage<StarlarkInstructionPosition> | undefined): boolean {
    return proto3.util.equals(StarlarkInstructionPosition, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkError
 */
export class StarlarkError extends Message<StarlarkError> {
  /**
   * @generated from oneof api_container_api.StarlarkError.error
   */
  error: {
    /**
     * @generated from field: api_container_api.StarlarkInterpretationError interpretation_error = 1;
     */
    value: StarlarkInterpretationError;
    case: "interpretationError";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkValidationError validation_error = 2;
     */
    value: StarlarkValidationError;
    case: "validationError";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkExecutionError execution_error = 3;
     */
    value: StarlarkExecutionError;
    case: "executionError";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StarlarkError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interpretation_error", kind: "message", T: StarlarkInterpretationError, oneof: "error" },
    { no: 2, name: "validation_error", kind: "message", T: StarlarkValidationError, oneof: "error" },
    { no: 3, name: "execution_error", kind: "message", T: StarlarkExecutionError, oneof: "error" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkError {
    return new StarlarkError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkError {
    return new StarlarkError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkError {
    return new StarlarkError().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkError | PlainMessage<StarlarkError> | undefined, b: StarlarkError | PlainMessage<StarlarkError> | undefined): boolean {
    return proto3.util.equals(StarlarkError, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkInterpretationError
 */
export class StarlarkInterpretationError extends Message<StarlarkInterpretationError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage = "";

  constructor(data?: PartialMessage<StarlarkInterpretationError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkInterpretationError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInterpretationError {
    return new StarlarkInterpretationError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInterpretationError {
    return new StarlarkInterpretationError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInterpretationError {
    return new StarlarkInterpretationError().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkInterpretationError | PlainMessage<StarlarkInterpretationError> | undefined, b: StarlarkInterpretationError | PlainMessage<StarlarkInterpretationError> | undefined): boolean {
    return proto3.util.equals(StarlarkInterpretationError, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkValidationError
 */
export class StarlarkValidationError extends Message<StarlarkValidationError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage = "";

  constructor(data?: PartialMessage<StarlarkValidationError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkValidationError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkValidationError {
    return new StarlarkValidationError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkValidationError {
    return new StarlarkValidationError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkValidationError {
    return new StarlarkValidationError().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkValidationError | PlainMessage<StarlarkValidationError> | undefined, b: StarlarkValidationError | PlainMessage<StarlarkValidationError> | undefined): boolean {
    return proto3.util.equals(StarlarkValidationError, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkExecutionError
 */
export class StarlarkExecutionError extends Message<StarlarkExecutionError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage = "";

  constructor(data?: PartialMessage<StarlarkExecutionError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkExecutionError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkExecutionError {
    return new StarlarkExecutionError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkExecutionError {
    return new StarlarkExecutionError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkExecutionError {
    return new StarlarkExecutionError().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkExecutionError | PlainMessage<StarlarkExecutionError> | undefined, b: StarlarkExecutionError | PlainMessage<StarlarkExecutionError> | undefined): boolean {
    return proto3.util.equals(StarlarkExecutionError, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkRunProgress
 */
export class StarlarkRunProgress extends Message<StarlarkRunProgress> {
  /**
   * @generated from field: repeated string current_step_info = 1;
   */
  currentStepInfo: string[] = [];

  /**
   * @generated from field: uint32 total_steps = 2;
   */
  totalSteps = 0;

  /**
   * @generated from field: uint32 current_step_number = 3;
   */
  currentStepNumber = 0;

  constructor(data?: PartialMessage<StarlarkRunProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkRunProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_step_info", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "total_steps", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "current_step_number", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkRunProgress {
    return new StarlarkRunProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkRunProgress {
    return new StarlarkRunProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkRunProgress {
    return new StarlarkRunProgress().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkRunProgress | PlainMessage<StarlarkRunProgress> | undefined, b: StarlarkRunProgress | PlainMessage<StarlarkRunProgress> | undefined): boolean {
    return proto3.util.equals(StarlarkRunProgress, a, b);
  }
}

/**
 * @generated from message api_container_api.StarlarkRunFinishedEvent
 */
export class StarlarkRunFinishedEvent extends Message<StarlarkRunFinishedEvent> {
  /**
   * @generated from field: bool is_run_successful = 1;
   */
  isRunSuccessful = false;

  /**
   * @generated from field: optional string serialized_output = 2;
   */
  serializedOutput?: string;

  constructor(data?: PartialMessage<StarlarkRunFinishedEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StarlarkRunFinishedEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_run_successful", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "serialized_output", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkRunFinishedEvent {
    return new StarlarkRunFinishedEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkRunFinishedEvent {
    return new StarlarkRunFinishedEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkRunFinishedEvent {
    return new StarlarkRunFinishedEvent().fromJsonString(jsonString, options);
  }

  static equals(a: StarlarkRunFinishedEvent | PlainMessage<StarlarkRunFinishedEvent> | undefined, b: StarlarkRunFinishedEvent | PlainMessage<StarlarkRunFinishedEvent> | undefined): boolean {
    return proto3.util.equals(StarlarkRunFinishedEvent, a, b);
  }
}

/**
 * ==============================================================================================
 *                                          Get Services
 * ==============================================================================================
 *
 * @generated from message api_container_api.GetServicesArgs
 */
export class GetServicesArgs extends Message<GetServicesArgs> {
  /**
   * "Set" of identifiers to fetch info for
   * If empty, will fetch info for all services
   *
   * @generated from field: map<string, bool> service_identifiers = 1;
   */
  serviceIdentifiers: { [key: string]: boolean } = {};

  constructor(data?: PartialMessage<GetServicesArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.GetServicesArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_identifiers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServicesArgs {
    return new GetServicesArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServicesArgs {
    return new GetServicesArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServicesArgs {
    return new GetServicesArgs().fromJsonString(jsonString, options);
  }

  static equals(a: GetServicesArgs | PlainMessage<GetServicesArgs> | undefined, b: GetServicesArgs | PlainMessage<GetServicesArgs> | undefined): boolean {
    return proto3.util.equals(GetServicesArgs, a, b);
  }
}

/**
 * @generated from message api_container_api.GetServicesResponse
 */
export class GetServicesResponse extends Message<GetServicesResponse> {
  /**
   * "Set" from identifiers -> info about the service
   *
   * @generated from field: map<string, api_container_api.ServiceInfo> service_info = 1;
   */
  serviceInfo: { [key: string]: ServiceInfo } = {};

  constructor(data?: PartialMessage<GetServicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.GetServicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ServiceInfo} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServicesResponse {
    return new GetServicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServicesResponse {
    return new GetServicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServicesResponse {
    return new GetServicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetServicesResponse | PlainMessage<GetServicesResponse> | undefined, b: GetServicesResponse | PlainMessage<GetServicesResponse> | undefined): boolean {
    return proto3.util.equals(GetServicesResponse, a, b);
  }
}

/**
 * An service identifier is a collection of uuid, name and shortened uuid
 *
 * @generated from message api_container_api.ServiceIdentifiers
 */
export class ServiceIdentifiers extends Message<ServiceIdentifiers> {
  /**
   * UUID of the service
   *
   * @generated from field: string service_uuid = 1;
   */
  serviceUuid = "";

  /**
   * Name of the service
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The shortened uuid of the service
   *
   * @generated from field: string shortened_uuid = 3;
   */
  shortenedUuid = "";

  constructor(data?: PartialMessage<ServiceIdentifiers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ServiceIdentifiers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "shortened_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceIdentifiers {
    return new ServiceIdentifiers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceIdentifiers {
    return new ServiceIdentifiers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceIdentifiers {
    return new ServiceIdentifiers().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceIdentifiers | PlainMessage<ServiceIdentifiers> | undefined, b: ServiceIdentifiers | PlainMessage<ServiceIdentifiers> | undefined): boolean {
    return proto3.util.equals(ServiceIdentifiers, a, b);
  }
}

/**
 * @generated from message api_container_api.GetExistingAndHistoricalServiceIdentifiersResponse
 */
export class GetExistingAndHistoricalServiceIdentifiersResponse extends Message<GetExistingAndHistoricalServiceIdentifiersResponse> {
  /**
   * @generated from field: repeated api_container_api.ServiceIdentifiers allIdentifiers = 1;
   */
  allIdentifiers: ServiceIdentifiers[] = [];

  constructor(data?: PartialMessage<GetExistingAndHistoricalServiceIdentifiersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.GetExistingAndHistoricalServiceIdentifiersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allIdentifiers", kind: "message", T: ServiceIdentifiers, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExistingAndHistoricalServiceIdentifiersResponse {
    return new GetExistingAndHistoricalServiceIdentifiersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExistingAndHistoricalServiceIdentifiersResponse {
    return new GetExistingAndHistoricalServiceIdentifiersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExistingAndHistoricalServiceIdentifiersResponse {
    return new GetExistingAndHistoricalServiceIdentifiersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetExistingAndHistoricalServiceIdentifiersResponse | PlainMessage<GetExistingAndHistoricalServiceIdentifiersResponse> | undefined, b: GetExistingAndHistoricalServiceIdentifiersResponse | PlainMessage<GetExistingAndHistoricalServiceIdentifiersResponse> | undefined): boolean {
    return proto3.util.equals(GetExistingAndHistoricalServiceIdentifiersResponse, a, b);
  }
}

/**
 * ==============================================================================================
 *                                          Exec Command
 * ==============================================================================================
 *
 * @generated from message api_container_api.ExecCommandArgs
 */
export class ExecCommandArgs extends Message<ExecCommandArgs> {
  /**
   * The service identifier of the container that the command should be executed in
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier = "";

  /**
   * @generated from field: repeated string command_args = 2;
   */
  commandArgs: string[] = [];

  constructor(data?: PartialMessage<ExecCommandArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ExecCommandArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "command_args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecCommandArgs {
    return new ExecCommandArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecCommandArgs {
    return new ExecCommandArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecCommandArgs {
    return new ExecCommandArgs().fromJsonString(jsonString, options);
  }

  static equals(a: ExecCommandArgs | PlainMessage<ExecCommandArgs> | undefined, b: ExecCommandArgs | PlainMessage<ExecCommandArgs> | undefined): boolean {
    return proto3.util.equals(ExecCommandArgs, a, b);
  }
}

/**
 * @generated from message api_container_api.ExecCommandResponse
 */
export class ExecCommandResponse extends Message<ExecCommandResponse> {
  /**
   * @generated from field: int32 exit_code = 1;
   */
  exitCode = 0;

  /**
   * Assumes UTF-8 encoding
   *
   * @generated from field: string log_output = 2;
   */
  logOutput = "";

  constructor(data?: PartialMessage<ExecCommandResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ExecCommandResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exit_code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "log_output", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecCommandResponse {
    return new ExecCommandResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecCommandResponse {
    return new ExecCommandResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecCommandResponse {
    return new ExecCommandResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecCommandResponse | PlainMessage<ExecCommandResponse> | undefined, b: ExecCommandResponse | PlainMessage<ExecCommandResponse> | undefined): boolean {
    return proto3.util.equals(ExecCommandResponse, a, b);
  }
}

/**
 * ==============================================================================================
 *                             Wait For HTTP Get Endpoint Availability
 * ==============================================================================================
 *
 * @generated from message api_container_api.WaitForHttpGetEndpointAvailabilityArgs
 */
export class WaitForHttpGetEndpointAvailabilityArgs extends Message<WaitForHttpGetEndpointAvailabilityArgs> {
  /**
   * The identifier of the service to check.
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier = "";

  /**
   * The port of the service to check. For instance 8080
   *
   * @generated from field: uint32 port = 2;
   */
  port = 0;

  /**
   * The path of the service to check. It mustn't start with the first slash. For instance `service/health`
   *
   * @generated from field: string path = 3;
   */
  path = "";

  /**
   * The number of milliseconds to wait until executing the first HTTP call
   *
   * @generated from field: uint32 initial_delay_milliseconds = 4;
   */
  initialDelayMilliseconds = 0;

  /**
   * Max number of HTTP call attempts that this will execute until giving up and returning an error
   *
   * @generated from field: uint32 retries = 5;
   */
  retries = 0;

  /**
   * Number of milliseconds to wait between retries
   *
   * @generated from field: uint32 retries_delay_milliseconds = 6;
   */
  retriesDelayMilliseconds = 0;

  /**
   * If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
   *
   * @generated from field: string body_text = 7;
   */
  bodyText = "";

  constructor(data?: PartialMessage<WaitForHttpGetEndpointAvailabilityArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.WaitForHttpGetEndpointAvailabilityArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "initial_delay_milliseconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "retries", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "retries_delay_milliseconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "body_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitForHttpGetEndpointAvailabilityArgs {
    return new WaitForHttpGetEndpointAvailabilityArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitForHttpGetEndpointAvailabilityArgs {
    return new WaitForHttpGetEndpointAvailabilityArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitForHttpGetEndpointAvailabilityArgs {
    return new WaitForHttpGetEndpointAvailabilityArgs().fromJsonString(jsonString, options);
  }

  static equals(a: WaitForHttpGetEndpointAvailabilityArgs | PlainMessage<WaitForHttpGetEndpointAvailabilityArgs> | undefined, b: WaitForHttpGetEndpointAvailabilityArgs | PlainMessage<WaitForHttpGetEndpointAvailabilityArgs> | undefined): boolean {
    return proto3.util.equals(WaitForHttpGetEndpointAvailabilityArgs, a, b);
  }
}

/**
 * ==============================================================================================
 *                           Wait For HTTP Post Endpoint Availability
 * ==============================================================================================
 *
 * @generated from message api_container_api.WaitForHttpPostEndpointAvailabilityArgs
 */
export class WaitForHttpPostEndpointAvailabilityArgs extends Message<WaitForHttpPostEndpointAvailabilityArgs> {
  /**
   * The identifier of the service to check.
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier = "";

  /**
   * The port of the service to check. For instance 8080
   *
   * @generated from field: uint32 port = 2;
   */
  port = 0;

  /**
   * The path of the service to check. It mustn't start with the first slash. For instance `service/health`
   *
   * @generated from field: string path = 3;
   */
  path = "";

  /**
   * The content of the request body.
   *
   * @generated from field: string request_body = 4;
   */
  requestBody = "";

  /**
   * The number of milliseconds to wait until executing the first HTTP call
   *
   * @generated from field: uint32 initial_delay_milliseconds = 5;
   */
  initialDelayMilliseconds = 0;

  /**
   * Max number of HTTP call attempts that this will execute until giving up and returning an error
   *
   * @generated from field: uint32 retries = 6;
   */
  retries = 0;

  /**
   * Number of milliseconds to wait between retries
   *
   * @generated from field: uint32 retries_delay_milliseconds = 7;
   */
  retriesDelayMilliseconds = 0;

  /**
   * If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
   *
   * @generated from field: string body_text = 8;
   */
  bodyText = "";

  constructor(data?: PartialMessage<WaitForHttpPostEndpointAvailabilityArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.WaitForHttpPostEndpointAvailabilityArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "request_body", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "initial_delay_milliseconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "retries", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "retries_delay_milliseconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "body_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitForHttpPostEndpointAvailabilityArgs {
    return new WaitForHttpPostEndpointAvailabilityArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitForHttpPostEndpointAvailabilityArgs {
    return new WaitForHttpPostEndpointAvailabilityArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitForHttpPostEndpointAvailabilityArgs {
    return new WaitForHttpPostEndpointAvailabilityArgs().fromJsonString(jsonString, options);
  }

  static equals(a: WaitForHttpPostEndpointAvailabilityArgs | PlainMessage<WaitForHttpPostEndpointAvailabilityArgs> | undefined, b: WaitForHttpPostEndpointAvailabilityArgs | PlainMessage<WaitForHttpPostEndpointAvailabilityArgs> | undefined): boolean {
    return proto3.util.equals(WaitForHttpPostEndpointAvailabilityArgs, a, b);
  }
}

/**
 * ==============================================================================================
 *                                          Streamed Data Chunk
 * ==============================================================================================
 *
 * @generated from message api_container_api.StreamedDataChunk
 */
export class StreamedDataChunk extends Message<StreamedDataChunk> {
  /**
   * Chunk of the overall files artifact bytes
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * Hash of the PREVIOUS chunk, or empty string is this is the first chunk
   * Referencing the previous chunk via its hash allows Kurtosis to validate
   * the consistency of the data in case some chunk were not received
   *
   * @generated from field: string previous_chunk_hash = 2;
   */
  previousChunkHash = "";

  /**
   * Additional metadata about the item being streamed
   *
   * @generated from field: api_container_api.DataChunkMetadata metadata = 3;
   */
  metadata?: DataChunkMetadata;

  constructor(data?: PartialMessage<StreamedDataChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StreamedDataChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "previous_chunk_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: DataChunkMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamedDataChunk {
    return new StreamedDataChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamedDataChunk {
    return new StreamedDataChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamedDataChunk {
    return new StreamedDataChunk().fromJsonString(jsonString, options);
  }

  static equals(a: StreamedDataChunk | PlainMessage<StreamedDataChunk> | undefined, b: StreamedDataChunk | PlainMessage<StreamedDataChunk> | undefined): boolean {
    return proto3.util.equals(StreamedDataChunk, a, b);
  }
}

/**
 * @generated from message api_container_api.DataChunkMetadata
 */
export class DataChunkMetadata extends Message<DataChunkMetadata> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DataChunkMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.DataChunkMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataChunkMetadata {
    return new DataChunkMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataChunkMetadata {
    return new DataChunkMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataChunkMetadata {
    return new DataChunkMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: DataChunkMetadata | PlainMessage<DataChunkMetadata> | undefined, b: DataChunkMetadata | PlainMessage<DataChunkMetadata> | undefined): boolean {
    return proto3.util.equals(DataChunkMetadata, a, b);
  }
}

/**
 * ==============================================================================================
 *                                          Upload Files Artifact
 * ==============================================================================================
 *
 * @generated from message api_container_api.UploadFilesArtifactResponse
 */
export class UploadFilesArtifactResponse extends Message<UploadFilesArtifactResponse> {
  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<UploadFilesArtifactResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.UploadFilesArtifactResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadFilesArtifactResponse {
    return new UploadFilesArtifactResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadFilesArtifactResponse {
    return new UploadFilesArtifactResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadFilesArtifactResponse {
    return new UploadFilesArtifactResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UploadFilesArtifactResponse | PlainMessage<UploadFilesArtifactResponse> | undefined, b: UploadFilesArtifactResponse | PlainMessage<UploadFilesArtifactResponse> | undefined): boolean {
    return proto3.util.equals(UploadFilesArtifactResponse, a, b);
  }
}

/**
 * ==============================================================================================
 *                                          Download Files Artifact
 * ==============================================================================================
 *
 * @generated from message api_container_api.DownloadFilesArtifactArgs
 */
export class DownloadFilesArtifactArgs extends Message<DownloadFilesArtifactArgs> {
  /**
   * Files identifier to get bytes for
   *
   * @generated from field: string identifier = 1;
   */
  identifier = "";

  constructor(data?: PartialMessage<DownloadFilesArtifactArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.DownloadFilesArtifactArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadFilesArtifactArgs {
    return new DownloadFilesArtifactArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadFilesArtifactArgs {
    return new DownloadFilesArtifactArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadFilesArtifactArgs {
    return new DownloadFilesArtifactArgs().fromJsonString(jsonString, options);
  }

  static equals(a: DownloadFilesArtifactArgs | PlainMessage<DownloadFilesArtifactArgs> | undefined, b: DownloadFilesArtifactArgs | PlainMessage<DownloadFilesArtifactArgs> | undefined): boolean {
    return proto3.util.equals(DownloadFilesArtifactArgs, a, b);
  }
}

/**
 * ==============================================================================================
 *                                        Store Web Files Artifact
 * ==============================================================================================
 *
 * @generated from message api_container_api.StoreWebFilesArtifactArgs
 */
export class StoreWebFilesArtifactArgs extends Message<StoreWebFilesArtifactArgs> {
  /**
   * URL to download the artifact from
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * The name of the files artifact
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<StoreWebFilesArtifactArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StoreWebFilesArtifactArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreWebFilesArtifactArgs {
    return new StoreWebFilesArtifactArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactArgs {
    return new StoreWebFilesArtifactArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactArgs {
    return new StoreWebFilesArtifactArgs().fromJsonString(jsonString, options);
  }

  static equals(a: StoreWebFilesArtifactArgs | PlainMessage<StoreWebFilesArtifactArgs> | undefined, b: StoreWebFilesArtifactArgs | PlainMessage<StoreWebFilesArtifactArgs> | undefined): boolean {
    return proto3.util.equals(StoreWebFilesArtifactArgs, a, b);
  }
}

/**
 * @generated from message api_container_api.StoreWebFilesArtifactResponse
 */
export class StoreWebFilesArtifactResponse extends Message<StoreWebFilesArtifactResponse> {
  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<StoreWebFilesArtifactResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StoreWebFilesArtifactResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreWebFilesArtifactResponse {
    return new StoreWebFilesArtifactResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactResponse {
    return new StoreWebFilesArtifactResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactResponse {
    return new StoreWebFilesArtifactResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StoreWebFilesArtifactResponse | PlainMessage<StoreWebFilesArtifactResponse> | undefined, b: StoreWebFilesArtifactResponse | PlainMessage<StoreWebFilesArtifactResponse> | undefined): boolean {
    return proto3.util.equals(StoreWebFilesArtifactResponse, a, b);
  }
}

/**
 * @generated from message api_container_api.StoreFilesArtifactFromServiceArgs
 */
export class StoreFilesArtifactFromServiceArgs extends Message<StoreFilesArtifactFromServiceArgs> {
  /**
   * Identifier that will be used to identify the service where the source files will be copied from
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier = "";

  /**
   * The absolute source path where the source files will be copied from
   *
   * @generated from field: string source_path = 2;
   */
  sourcePath = "";

  /**
   * The name of the files artifact
   *
   * @generated from field: string name = 3;
   */
  name = "";

  constructor(data?: PartialMessage<StoreFilesArtifactFromServiceArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StoreFilesArtifactFromServiceArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreFilesArtifactFromServiceArgs {
    return new StoreFilesArtifactFromServiceArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceArgs {
    return new StoreFilesArtifactFromServiceArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceArgs {
    return new StoreFilesArtifactFromServiceArgs().fromJsonString(jsonString, options);
  }

  static equals(a: StoreFilesArtifactFromServiceArgs | PlainMessage<StoreFilesArtifactFromServiceArgs> | undefined, b: StoreFilesArtifactFromServiceArgs | PlainMessage<StoreFilesArtifactFromServiceArgs> | undefined): boolean {
    return proto3.util.equals(StoreFilesArtifactFromServiceArgs, a, b);
  }
}

/**
 * @generated from message api_container_api.StoreFilesArtifactFromServiceResponse
 */
export class StoreFilesArtifactFromServiceResponse extends Message<StoreFilesArtifactFromServiceResponse> {
  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<StoreFilesArtifactFromServiceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.StoreFilesArtifactFromServiceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreFilesArtifactFromServiceResponse {
    return new StoreFilesArtifactFromServiceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceResponse {
    return new StoreFilesArtifactFromServiceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceResponse {
    return new StoreFilesArtifactFromServiceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StoreFilesArtifactFromServiceResponse | PlainMessage<StoreFilesArtifactFromServiceResponse> | undefined, b: StoreFilesArtifactFromServiceResponse | PlainMessage<StoreFilesArtifactFromServiceResponse> | undefined): boolean {
    return proto3.util.equals(StoreFilesArtifactFromServiceResponse, a, b);
  }
}

/**
 * @generated from message api_container_api.FilesArtifactNameAndUuid
 */
export class FilesArtifactNameAndUuid extends Message<FilesArtifactNameAndUuid> {
  /**
   * A string representing the name of the file
   *
   * @generated from field: string fileName = 1;
   */
  fileName = "";

  /**
   * A string representing the uuid of the file
   *
   * @generated from field: string fileUuid = 2;
   */
  fileUuid = "";

  constructor(data?: PartialMessage<FilesArtifactNameAndUuid>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.FilesArtifactNameAndUuid";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fileName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fileUuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilesArtifactNameAndUuid {
    return new FilesArtifactNameAndUuid().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilesArtifactNameAndUuid {
    return new FilesArtifactNameAndUuid().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilesArtifactNameAndUuid {
    return new FilesArtifactNameAndUuid().fromJsonString(jsonString, options);
  }

  static equals(a: FilesArtifactNameAndUuid | PlainMessage<FilesArtifactNameAndUuid> | undefined, b: FilesArtifactNameAndUuid | PlainMessage<FilesArtifactNameAndUuid> | undefined): boolean {
    return proto3.util.equals(FilesArtifactNameAndUuid, a, b);
  }
}

/**
 * @generated from message api_container_api.ListFilesArtifactNamesAndUuidsResponse
 */
export class ListFilesArtifactNamesAndUuidsResponse extends Message<ListFilesArtifactNamesAndUuidsResponse> {
  /**
   * @generated from field: repeated api_container_api.FilesArtifactNameAndUuid file_names_and_uuids = 1;
   */
  fileNamesAndUuids: FilesArtifactNameAndUuid[] = [];

  constructor(data?: PartialMessage<ListFilesArtifactNamesAndUuidsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ListFilesArtifactNamesAndUuidsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file_names_and_uuids", kind: "message", T: FilesArtifactNameAndUuid, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFilesArtifactNamesAndUuidsResponse {
    return new ListFilesArtifactNamesAndUuidsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFilesArtifactNamesAndUuidsResponse {
    return new ListFilesArtifactNamesAndUuidsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFilesArtifactNamesAndUuidsResponse {
    return new ListFilesArtifactNamesAndUuidsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListFilesArtifactNamesAndUuidsResponse | PlainMessage<ListFilesArtifactNamesAndUuidsResponse> | undefined, b: ListFilesArtifactNamesAndUuidsResponse | PlainMessage<ListFilesArtifactNamesAndUuidsResponse> | undefined): boolean {
    return proto3.util.equals(ListFilesArtifactNamesAndUuidsResponse, a, b);
  }
}

/**
 * @generated from message api_container_api.InspectFilesArtifactContentsRequest
 */
export class InspectFilesArtifactContentsRequest extends Message<InspectFilesArtifactContentsRequest> {
  /**
   * @generated from field: api_container_api.FilesArtifactNameAndUuid file_names_and_uuid = 1;
   */
  fileNamesAndUuid?: FilesArtifactNameAndUuid;

  constructor(data?: PartialMessage<InspectFilesArtifactContentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.InspectFilesArtifactContentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file_names_and_uuid", kind: "message", T: FilesArtifactNameAndUuid },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectFilesArtifactContentsRequest {
    return new InspectFilesArtifactContentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsRequest {
    return new InspectFilesArtifactContentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsRequest {
    return new InspectFilesArtifactContentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InspectFilesArtifactContentsRequest | PlainMessage<InspectFilesArtifactContentsRequest> | undefined, b: InspectFilesArtifactContentsRequest | PlainMessage<InspectFilesArtifactContentsRequest> | undefined): boolean {
    return proto3.util.equals(InspectFilesArtifactContentsRequest, a, b);
  }
}

/**
 * @generated from message api_container_api.InspectFilesArtifactContentsResponse
 */
export class InspectFilesArtifactContentsResponse extends Message<InspectFilesArtifactContentsResponse> {
  /**
   * @generated from field: repeated api_container_api.FileArtifactContentsFileDescription file_descriptions = 1;
   */
  fileDescriptions: FileArtifactContentsFileDescription[] = [];

  constructor(data?: PartialMessage<InspectFilesArtifactContentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.InspectFilesArtifactContentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file_descriptions", kind: "message", T: FileArtifactContentsFileDescription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectFilesArtifactContentsResponse {
    return new InspectFilesArtifactContentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsResponse {
    return new InspectFilesArtifactContentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsResponse {
    return new InspectFilesArtifactContentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InspectFilesArtifactContentsResponse | PlainMessage<InspectFilesArtifactContentsResponse> | undefined, b: InspectFilesArtifactContentsResponse | PlainMessage<InspectFilesArtifactContentsResponse> | undefined): boolean {
    return proto3.util.equals(InspectFilesArtifactContentsResponse, a, b);
  }
}

/**
 * @generated from message api_container_api.FileArtifactContentsFileDescription
 */
export class FileArtifactContentsFileDescription extends Message<FileArtifactContentsFileDescription> {
  /**
   * Path relative to the file artifact
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * Size of the file, in bytes
   *
   * @generated from field: uint64 size = 2;
   */
  size = protoInt64.zero;

  /**
   * A bit of text content, if the file allows (similar to UNIX's 'head')
   *
   * @generated from field: optional string text_preview = 3;
   */
  textPreview?: string;

  constructor(data?: PartialMessage<FileArtifactContentsFileDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.FileArtifactContentsFileDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "text_preview", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileArtifactContentsFileDescription {
    return new FileArtifactContentsFileDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileArtifactContentsFileDescription {
    return new FileArtifactContentsFileDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileArtifactContentsFileDescription {
    return new FileArtifactContentsFileDescription().fromJsonString(jsonString, options);
  }

  static equals(a: FileArtifactContentsFileDescription | PlainMessage<FileArtifactContentsFileDescription> | undefined, b: FileArtifactContentsFileDescription | PlainMessage<FileArtifactContentsFileDescription> | undefined): boolean {
    return proto3.util.equals(FileArtifactContentsFileDescription, a, b);
  }
}

/**
 * @generated from message api_container_api.ConnectServicesArgs
 */
export class ConnectServicesArgs extends Message<ConnectServicesArgs> {
  /**
   * @generated from field: api_container_api.Connect connect = 1;
   */
  connect = Connect.CONNECT;

  constructor(data?: PartialMessage<ConnectServicesArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ConnectServicesArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connect", kind: "enum", T: proto3.getEnumType(Connect) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectServicesArgs {
    return new ConnectServicesArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectServicesArgs {
    return new ConnectServicesArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectServicesArgs {
    return new ConnectServicesArgs().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectServicesArgs | PlainMessage<ConnectServicesArgs> | undefined, b: ConnectServicesArgs | PlainMessage<ConnectServicesArgs> | undefined): boolean {
    return proto3.util.equals(ConnectServicesArgs, a, b);
  }
}

/**
 * @generated from message api_container_api.ConnectServicesResponse
 */
export class ConnectServicesResponse extends Message<ConnectServicesResponse> {
  constructor(data?: PartialMessage<ConnectServicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.ConnectServicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectServicesResponse {
    return new ConnectServicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectServicesResponse {
    return new ConnectServicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectServicesResponse {
    return new ConnectServicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectServicesResponse | PlainMessage<ConnectServicesResponse> | undefined, b: ConnectServicesResponse | PlainMessage<ConnectServicesResponse> | undefined): boolean {
    return proto3.util.equals(ConnectServicesResponse, a, b);
  }
}

/**
 * @generated from message api_container_api.GetStarlarkRunResponse
 */
export class GetStarlarkRunResponse extends Message<GetStarlarkRunResponse> {
  /**
   * @generated from field: string package_id = 1;
   */
  packageId = "";

  /**
   * @generated from field: string serialized_script = 2;
   */
  serializedScript = "";

  /**
   * @generated from field: string serialized_params = 3;
   */
  serializedParams = "";

  /**
   * @generated from field: int32 parallelism = 4;
   */
  parallelism = 0;

  /**
   * @generated from field: string relative_path_to_main_file = 5;
   */
  relativePathToMainFile = "";

  /**
   * @generated from field: string main_function_name = 6;
   */
  mainFunctionName = "";

  /**
   * @generated from field: repeated api_container_api.KurtosisFeatureFlag experimental_features = 7;
   */
  experimentalFeatures: KurtosisFeatureFlag[] = [];

  /**
   * @generated from field: api_container_api.RestartPolicy restart_policy = 8;
   */
  restartPolicy = RestartPolicy.NEVER;

  constructor(data?: PartialMessage<GetStarlarkRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api_container_api.GetStarlarkRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "package_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "serialized_script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "serialized_params", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "parallelism", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "relative_path_to_main_file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "main_function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "experimental_features", kind: "enum", T: proto3.getEnumType(KurtosisFeatureFlag), repeated: true },
    { no: 8, name: "restart_policy", kind: "enum", T: proto3.getEnumType(RestartPolicy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStarlarkRunResponse {
    return new GetStarlarkRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStarlarkRunResponse {
    return new GetStarlarkRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStarlarkRunResponse {
    return new GetStarlarkRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStarlarkRunResponse | PlainMessage<GetStarlarkRunResponse> | undefined, b: GetStarlarkRunResponse | PlainMessage<GetStarlarkRunResponse> | undefined): boolean {
    return proto3.util.equals(GetStarlarkRunResponse, a, b);
  }
}

